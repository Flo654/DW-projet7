{"version":3,"file":"VueFinalModal.umd.js","sources":["../lib/utils/focusTrap.js","../lib/utils/bodyScrollLock.js","../lib/VueFinalModal.vue","../lib/VueFinalModal.vue?vue&type=template&id=2836fdb5&lang.js","../lib/PluginCore.js","../node_modules/style-inject/dist/style-inject.es.js","../lib/utils/errors.js","../lib/Plugin.js"],"sourcesContent":["// stolen from vue-js-modal\n\nconst FOCUSABLE_ELEMENTS_QUERY =\n  'button:not([disabled]), ' +\n  'select:not([disabled]), ' +\n  'a[href]:not([disabled]), ' +\n  'area[href]:not([disabled]), ' +\n  '[contentEditable=\"\"]:not([disabled]), ' +\n  '[contentEditable=\"true\"]:not([disabled]), ' +\n  '[contentEditable=\"TRUE\"]:not([disabled]), ' +\n  'textarea:not([disabled]), ' +\n  'iframe:not([disabled]), ' +\n  'input:not([disabled]), ' +\n  'summary:not([disabled]), ' +\n  '[tabindex]:not([tabindex=\"-1\"])'\n\nconst isTabPressed = event => {\n  return event.key === 'Tab' || event.keyCode === 9\n}\n\nconst querySelectorAll = (element, selector) => {\n  return [...(element.querySelectorAll(selector) || [])]\n}\n\nconst queryFocusableElements = element => {\n  return querySelectorAll(element, FOCUSABLE_ELEMENTS_QUERY)\n}\n\nconst isFocused = element => {\n  return element == document.activeElement\n}\n\nconst isNothingFocused = () => {\n  return !document.activeElement\n}\n\nclass FocusTrap {\n  constructor() {\n    this.root = null\n    this.elements = []\n\n    this.onKeyDown = this.onKeyDown.bind(this)\n    this.enable = this.enable.bind(this)\n    this.disable = this.disable.bind(this)\n    this.firstElement = this.firstElement.bind(this)\n    this.lastElement = this.lastElement.bind(this)\n  }\n\n  lastElement() {\n    return this.elements[this.elements.length - 1] || null\n  }\n\n  firstElement() {\n    return this.elements[0] || null\n  }\n\n  onKeyDown(event) {\n    if (!isTabPressed(event)) {\n      return\n    }\n\n    // SHIFT + TAB\n    if (event.shiftKey) {\n      if (isFocused(this.firstElement())) {\n        this.lastElement().focus()\n        event.preventDefault()\n      }\n      return\n    }\n\n    // TAB\n    if (isNothingFocused() || isFocused(this.lastElement())) {\n      this.firstElement().focus()\n      event.preventDefault()\n      return\n    }\n  }\n\n  enabled() {\n    return !!this.root\n  }\n\n  enable(root) {\n    if (!root) {\n      return\n    }\n\n    this.root = root\n    this.elements = queryFocusableElements(this.root)\n\n    this.root.addEventListener('keydown', this.onKeyDown)\n  }\n\n  disable() {\n    this.root.removeEventListener('keydown', this.onKeyDown)\n    this.root = null\n  }\n}\n\nexport default FocusTrap\n","// stolen from body-scroll-lock and removed ios part\n\nlet locks = []\nlet previousBodyOverflowSetting\nlet previousBodyPaddingRight\n\nconst setOverflowHidden = options => {\n  // If previousBodyPaddingRight is already set, don't set it again.\n  if (previousBodyPaddingRight === undefined) {\n    const reserveScrollBarGap = !!options && options.reserveScrollBarGap === true\n    const scrollBarGap = window.innerWidth - document.documentElement.clientWidth\n\n    if (reserveScrollBarGap && scrollBarGap > 0) {\n      const computedBodyPaddingRight = parseInt(getComputedStyle(document.body).getPropertyValue('padding-right'), 10)\n      previousBodyPaddingRight = document.body.style.paddingRight\n      document.body.style.paddingRight = `${computedBodyPaddingRight + scrollBarGap}px`\n    }\n  }\n  // If previousBodyOverflowSetting is already set, don't set it again.\n  if (previousBodyOverflowSetting === undefined) {\n    previousBodyOverflowSetting = document.body.style.overflow\n    document.body.style.overflow = 'hidden'\n  }\n}\n\nconst restoreOverflowSetting = () => {\n  if (previousBodyPaddingRight !== undefined) {\n    document.body.style.paddingRight = previousBodyPaddingRight\n\n    // Restore previousBodyPaddingRight to undefined so setOverflowHidden knows it\n    // can be set again.\n    previousBodyPaddingRight = undefined\n  }\n\n  if (previousBodyOverflowSetting !== undefined) {\n    document.body.style.overflow = previousBodyOverflowSetting\n\n    // Restore previousBodyOverflowSetting to undefined\n    // so setOverflowHidden knows it can be set again.\n    previousBodyOverflowSetting = undefined\n  }\n}\n\nexport const disableBodyScroll = (targetElement, options) => {\n  // targetElement must be provided\n  if (!targetElement) {\n    // eslint-disable-next-line no-console\n    console.error(\n      'disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.'\n    )\n    return\n  }\n\n  // disableBodyScroll must not have been called on this targetElement before\n  if (locks.some(lock => lock.targetElement === targetElement)) {\n    return\n  }\n\n  const lock = {\n    targetElement,\n    options: options || {}\n  }\n\n  locks = [...locks, lock]\n\n  setOverflowHidden(options)\n}\n\nexport const enableBodyScroll = targetElement => {\n  if (!targetElement) {\n    // eslint-disable-next-line no-console\n    console.error(\n      'enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.'\n    )\n    return\n  }\n\n  locks = locks.filter(lock => lock.targetElement !== targetElement)\n\n  if (!locks.length) {\n    restoreOverflowSetting()\n  }\n}\n","<template>\n  <div\n    v-if=\"ssr || visible\"\n    v-show=\"!ssr || visible\"\n    ref=\"root\"\n    :style=\"bindStyle\"\n    class=\"vfm vfm--inset\"\n    :class=\"[attach === false ? 'vfm--fixed' : 'vfm--absolute', { 'vfm--prevent-none': preventClick }]\"\n    @keydown=\"onEsc\"\n  >\n    <transition\n      :name=\"overlayTransition\"\n      @before-enter=\"beforeOverlayEnter\"\n      @after-enter=\"afterOverlayEnter\"\n      @before-leave=\"beforeOverlayLeave\"\n      @after-leave=\"afterOverlayLeave\"\n    >\n      <div\n        v-if=\"!hideOverlay && visibility.overlay\"\n        class=\"vfm__overlay vfm--overlay vfm--absolute vfm--inset\"\n        :class=\"overlayClass\"\n        :style=\"overlayStyle\"\n      ></div>\n    </transition>\n    <transition\n      :name=\"transition\"\n      @before-enter=\"beforeModalEnter\"\n      @after-enter=\"afterModalEnter\"\n      @before-leave=\"beforeModalLeave\"\n      @after-leave=\"afterModalLeave\"\n    >\n      <div\n        v-show=\"visibility.modal\"\n        ref=\"vfmContainer\"\n        class=\"vfm__container vfm--absolute vfm--inset vfm--outline-none\"\n        :class=\"classes\"\n        :style=\"styles\"\n        :aria-expanded=\"visibility.modal.toString()\"\n        role=\"dialog\"\n        aria-modal=\"true\"\n        tabindex=\"-1\"\n        @click.self=\"onClickContainer\"\n      >\n        <div\n          ref=\"vfmContent\"\n          class=\"vfm__content\"\n          :class=\"[contentClass, { 'vfm--prevent-auto': preventClick }]\"\n          :style=\"contentStyle\"\n        >\n          <slot :params=\"params\" />\n        </div>\n      </div>\n    </transition>\n  </div>\n</template>\n\n<script>\nimport { ref, reactive, onMounted, onBeforeUnmount, computed, nextTick, watch, inject } from 'vue'\nimport FocusTrap from './utils/focusTrap.js'\nimport { disableBodyScroll, enableBodyScroll } from './utils/bodyScrollLock'\n\nconst TransitionState = {\n  Enter: 'enter',\n  Entering: 'entering',\n  Leave: 'leave',\n  Leaving: 'leavng'\n}\n\nexport default {\n  name: 'VueFinalModal',\n  props: {\n    name: { type: String, default: null },\n    modelValue: { type: Boolean, default: false },\n    ssr: { type: Boolean, default: true },\n    classes: { type: [String, Object, Array], default: '' },\n    overlayClass: { type: [String, Object, Array], default: '' },\n    contentClass: { type: [String, Object, Array], default: '' },\n    styles: { type: [String, Object, Array], default: '' },\n    overlayStyle: { type: [String, Object, Array], default: '' },\n    contentStyle: { type: [String, Object, Array], default: '' },\n    lockScroll: { type: Boolean, default: true },\n    hideOverlay: { type: Boolean, default: false },\n    clickToClose: { type: Boolean, default: true },\n    escToClose: { type: Boolean, default: false },\n    preventClick: { type: Boolean, default: false },\n    attach: {\n      type: null,\n      default: false,\n      validator(val) {\n        const type = typeof val\n\n        if (type === 'boolean' || type === 'string') return true\n\n        return val.nodeType === Node.ELEMENT_NODE\n      }\n    },\n    transition: { type: String, default: 'vfm' },\n    overlayTransition: { type: String, default: 'vfm' },\n    zIndexAuto: { type: Boolean, default: true },\n    zIndexBase: { type: [String, Number], default: 1000 },\n    zIndex: { type: [Boolean, String, Number], default: false },\n    focusRetain: { type: Boolean, default: true },\n    focusTrap: { type: Boolean, default: false }\n  },\n  emits: ['update:modelValue', 'click-outside', 'before-open', 'opened', 'before-close', 'closed'],\n  setup(props, { emit }) {\n    const uid = Symbol('vfm')\n    const root = ref(null)\n    const vfmContent = ref(null)\n    const vfmContainer = ref(null)\n\n    const $vfm = inject(props.options.key)\n\n    const modalStackIndex = ref(null)\n    const $focusTrap = new FocusTrap()\n\n    const visible = ref(false)\n    const visibility = reactive({\n      modal: false,\n      overlay: false\n    })\n    const overlayTransitionState = ref(null)\n    const modalTransitionState = ref(null)\n    const _stopEvent = ref(false)\n    const params = ref({})\n\n    const isComponentReadyToBeDestroyed = computed(() => {\n      return (\n        (props.hideOverlay || overlayTransitionState.value === TransitionState.Leave) &&\n        modalTransitionState.value === TransitionState.Leave\n      )\n    })\n\n    const calculateZIndex = computed(() => {\n      if (props.zIndex === false) {\n        if (props.zIndexAuto) {\n          return +props.zIndexBase + 2 * (modalStackIndex.value || 0)\n        } else {\n          return false\n        }\n      } else {\n        return props.zIndex\n      }\n    })\n\n    const bindStyle = computed(() => {\n      return {\n        ...(calculateZIndex.value !== false && {\n          zIndex: calculateZIndex.value\n        })\n      }\n    })\n\n    watch(\n      () => props.modelValue,\n      value => {\n        if (_stopEvent.value) {\n          _stopEvent.value = false\n          return\n        }\n        mounted()\n        if (!value) {\n          if (emitEvent('before-close', true)) {\n            return\n          }\n          close()\n        }\n      }\n    )\n    watch(() => props.lockScroll, handleLockScroll)\n    watch(\n      () => props.hideOverlay,\n      value => {\n        if (props.modelValue && !value) {\n          visibility.overlay = true\n        }\n      }\n    )\n    watch(() => props.attach, mounted)\n    watch(\n      isComponentReadyToBeDestroyed,\n      val => {\n        if (val) {\n          visible.value = false\n        }\n      },\n      {\n        flush: 'post'\n      }\n    )\n\n    $vfm.modals.push(getModalInfo())\n\n    onMounted(() => {\n      mounted()\n    })\n    onBeforeUnmount(() => {\n      close()\n      props.lockScroll && enableBodyScroll(vfmContent)\n      root?.value?.remove()\n\n      let index = $vfm.modals.findIndex(vm => vm.uid === uid)\n      $vfm.modals.splice(index, 1)\n    })\n    function getModalInfo() {\n      return {\n        uid,\n        props,\n        emit,\n        vfmContainer,\n        vfmContent,\n        getAttachElement,\n        modalStackIndex,\n        visibility,\n        handleLockScroll,\n        $focusTrap,\n        toggle,\n        params\n      }\n    }\n    function mounted() {\n      if (props.modelValue) {\n        if (emitEvent('before-open', false)) {\n          return\n        }\n\n        let target = getAttachElement()\n        if (target || props.attach === false) {\n          props.attach !== false && target.appendChild(root.value)\n\n          let index = $vfm.openedModals.findIndex(vm => vm.uid === uid)\n\n          if (index !== -1) {\n            // if this is already exist in modalStack, delete it\n            $vfm.openedModals.splice(index, 1)\n          }\n          $vfm.openedModals.push(getModalInfo())\n\n          modalStackIndex.value = $vfm.openedModals.length - 1\n\n          handleLockScroll()\n\n          $vfm.openedModals\n            .filter(vm => vm.uid !== uid)\n            .forEach((vm, index) => {\n              if (vm.getAttachElement() === target) {\n                // if vm and this have the same attach element\n                vm.modalStackIndex.value = index\n                vm.visibility.overlay = false\n              }\n            })\n\n          visible.value = true\n          nextTick(() => {\n            startTransitionEnter()\n          })\n        } else if (target !== false) {\n          console.warn('Unable to locate target '.concat(props.attach))\n        }\n      }\n    }\n    function close() {\n      let index = $vfm.openedModals.findIndex(vm => vm.uid === uid)\n      if (index !== -1) {\n        // remove this in modalStack\n        $vfm.openedModals.splice(index, 1)\n      }\n      if ($vfm.openedModals.length > 0) {\n        // If there are still nested modals opened\n        const $_vm = $vfm.openedModals[$vfm.openedModals.length - 1]\n        $_vm.props.focusTrap && $_vm.$focusTrap.firstElement().focus()\n        if ($_vm.props.focusRetain || $_vm.props.focusTrap) {\n          $_vm.vfmContainer.value.focus()\n        }\n        !$_vm.props.hideOverlay && ($_vm.visibility.overlay = true)\n      }\n      startTransitionLeave()\n    }\n    function handleLockScroll() {\n      if (props.modelValue) {\n        if (props.lockScroll) {\n          disableBodyScroll(vfmContent, {\n            reserveScrollBarGap: true\n          })\n        } else {\n          enableBodyScroll(vfmContent)\n        }\n      }\n    }\n    function getAttachElement() {\n      let target\n      if (props.attach === false) {\n        target = false\n      } else if (typeof props.attach === 'string') {\n        // CSS selector\n        if (window) {\n          target = window.document.querySelector(props.attach)\n        } else {\n          target = false\n        }\n      } else {\n        // DOM Element\n        target = props.attach\n      }\n      return target\n    }\n    function startTransitionEnter() {\n      visibility.overlay = true\n      visibility.modal = true\n    }\n    function startTransitionLeave() {\n      visibility.overlay = false\n      visibility.modal = false\n    }\n\n    function beforeOverlayEnter() {\n      overlayTransitionState.value = TransitionState.Entering\n    }\n    function afterOverlayEnter() {\n      overlayTransitionState.value = TransitionState.Enter\n    }\n    function beforeOverlayLeave() {\n      overlayTransitionState.value = TransitionState.Leaving\n    }\n    function afterOverlayLeave() {\n      overlayTransitionState.value = TransitionState.Leave\n    }\n    function beforeModalEnter() {\n      modalTransitionState.value = TransitionState.Entering\n    }\n    function afterModalEnter() {\n      modalTransitionState.value = TransitionState.Enter\n      if (props.focusRetain || props.focusTrap) {\n        vfmContainer.value.focus()\n      }\n      if (props.focusTrap) {\n        $focusTrap.enable(vfmContainer.value)\n      }\n      emit('opened', createModalEvent({ type: 'opened' }))\n    }\n    function beforeModalLeave() {\n      modalTransitionState.value = TransitionState.Leaving\n\n      if ($focusTrap.enabled()) {\n        $focusTrap.disable()\n      }\n    }\n    function afterModalLeave() {\n      modalTransitionState.value = TransitionState.Leave\n      modalStackIndex.value = null\n      props.lockScroll && enableBodyScroll(vfmContent)\n\n      let stopEvent = false\n      const event = createModalEvent({\n        type: 'closed',\n        stop() {\n          stopEvent = true\n        }\n      })\n      emit('closed', event)\n      if (stopEvent) return\n      params.value = {}\n    }\n    function onClickContainer() {\n      emit('click-outside', createModalEvent({ type: 'click-outside' }))\n      props.clickToClose && emit('update:modelValue', false)\n    }\n    function onEsc(evt) {\n      if (evt.keyCode === 27 && visible.value && props.escToClose) {\n        emit('update:modelValue', false)\n      }\n    }\n    function createModalEvent(eventProps = {}) {\n      return {\n        ref: getModalInfo(),\n        ...eventProps\n      }\n    }\n    function emitEvent(eventType, value) {\n      let stopEvent = false\n      const event = createModalEvent({\n        type: eventType,\n        stop() {\n          stopEvent = true\n        }\n      })\n      emit(eventType, event)\n      if (stopEvent) {\n        _stopEvent.value = true\n        nextTick(() => {\n          emit('update:modelValue', value)\n        })\n        return true\n      }\n      return false\n    }\n    function toggle(show, _params) {\n      const value = typeof show === 'boolean' ? show : !props.modelValue\n      if (value && arguments.length === 2) {\n        params.value = _params\n      }\n      emit('update:modelValue', value)\n    }\n    return {\n      root,\n      vfmContent,\n      vfmContainer,\n      visible,\n      visibility,\n      params,\n      calculateZIndex,\n      bindStyle,\n      beforeOverlayEnter,\n      afterOverlayEnter,\n      beforeOverlayLeave,\n      afterOverlayLeave,\n      beforeModalEnter,\n      afterModalEnter,\n      beforeModalLeave,\n      afterModalLeave,\n      onClickContainer,\n      onEsc\n    }\n  }\n}\n</script>\n\n<style lang=\"css\" scoped>\n.vfm--fixed {\n  position: fixed;\n}\n.vfm--absolute {\n  position: absolute;\n}\n.vfm--inset {\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.vfm--overlay {\n  background-color: rgba(0, 0, 0, 0.5);\n}\n.vfm--prevent-none {\n  pointer-events: none;\n}\n.vfm--prevent-auto {\n  pointer-events: auto;\n}\n.vfm--outline-none:focus {\n  outline: none;\n}\n.vfm-enter-active,\n.vfm-leave-active {\n  transition: opacity 0.2s;\n}\n.vfm-enter-from,\n.vfm-leave-to {\n  opacity: 0;\n}\n</style>\n","<template>\n  <div\n    v-if=\"ssr || visible\"\n    v-show=\"!ssr || visible\"\n    ref=\"root\"\n    :style=\"bindStyle\"\n    class=\"vfm vfm--inset\"\n    :class=\"[attach === false ? 'vfm--fixed' : 'vfm--absolute', { 'vfm--prevent-none': preventClick }]\"\n    @keydown=\"onEsc\"\n  >\n    <transition\n      :name=\"overlayTransition\"\n      @before-enter=\"beforeOverlayEnter\"\n      @after-enter=\"afterOverlayEnter\"\n      @before-leave=\"beforeOverlayLeave\"\n      @after-leave=\"afterOverlayLeave\"\n    >\n      <div\n        v-if=\"!hideOverlay && visibility.overlay\"\n        class=\"vfm__overlay vfm--overlay vfm--absolute vfm--inset\"\n        :class=\"overlayClass\"\n        :style=\"overlayStyle\"\n      ></div>\n    </transition>\n    <transition\n      :name=\"transition\"\n      @before-enter=\"beforeModalEnter\"\n      @after-enter=\"afterModalEnter\"\n      @before-leave=\"beforeModalLeave\"\n      @after-leave=\"afterModalLeave\"\n    >\n      <div\n        v-show=\"visibility.modal\"\n        ref=\"vfmContainer\"\n        class=\"vfm__container vfm--absolute vfm--inset vfm--outline-none\"\n        :class=\"classes\"\n        :style=\"styles\"\n        :aria-expanded=\"visibility.modal.toString()\"\n        role=\"dialog\"\n        aria-modal=\"true\"\n        tabindex=\"-1\"\n        @click.self=\"onClickContainer\"\n      >\n        <div\n          ref=\"vfmContent\"\n          class=\"vfm__content\"\n          :class=\"[contentClass, { 'vfm--prevent-auto': preventClick }]\"\n          :style=\"contentStyle\"\n        >\n          <slot :params=\"params\" />\n        </div>\n      </div>\n    </transition>\n  </div>\n</template>\n\n<script>\nimport { ref, reactive, onMounted, onBeforeUnmount, computed, nextTick, watch, inject } from 'vue'\nimport FocusTrap from './utils/focusTrap.js'\nimport { disableBodyScroll, enableBodyScroll } from './utils/bodyScrollLock'\n\nconst TransitionState = {\n  Enter: 'enter',\n  Entering: 'entering',\n  Leave: 'leave',\n  Leaving: 'leavng'\n}\n\nexport default {\n  name: 'VueFinalModal',\n  props: {\n    name: { type: String, default: null },\n    modelValue: { type: Boolean, default: false },\n    ssr: { type: Boolean, default: true },\n    classes: { type: [String, Object, Array], default: '' },\n    overlayClass: { type: [String, Object, Array], default: '' },\n    contentClass: { type: [String, Object, Array], default: '' },\n    styles: { type: [String, Object, Array], default: '' },\n    overlayStyle: { type: [String, Object, Array], default: '' },\n    contentStyle: { type: [String, Object, Array], default: '' },\n    lockScroll: { type: Boolean, default: true },\n    hideOverlay: { type: Boolean, default: false },\n    clickToClose: { type: Boolean, default: true },\n    escToClose: { type: Boolean, default: false },\n    preventClick: { type: Boolean, default: false },\n    attach: {\n      type: null,\n      default: false,\n      validator(val) {\n        const type = typeof val\n\n        if (type === 'boolean' || type === 'string') return true\n\n        return val.nodeType === Node.ELEMENT_NODE\n      }\n    },\n    transition: { type: String, default: 'vfm' },\n    overlayTransition: { type: String, default: 'vfm' },\n    zIndexAuto: { type: Boolean, default: true },\n    zIndexBase: { type: [String, Number], default: 1000 },\n    zIndex: { type: [Boolean, String, Number], default: false },\n    focusRetain: { type: Boolean, default: true },\n    focusTrap: { type: Boolean, default: false }\n  },\n  emits: ['update:modelValue', 'click-outside', 'before-open', 'opened', 'before-close', 'closed'],\n  setup(props, { emit }) {\n    const uid = Symbol('vfm')\n    const root = ref(null)\n    const vfmContent = ref(null)\n    const vfmContainer = ref(null)\n\n    const $vfm = inject(props.options.key)\n\n    const modalStackIndex = ref(null)\n    const $focusTrap = new FocusTrap()\n\n    const visible = ref(false)\n    const visibility = reactive({\n      modal: false,\n      overlay: false\n    })\n    const overlayTransitionState = ref(null)\n    const modalTransitionState = ref(null)\n    const _stopEvent = ref(false)\n    const params = ref({})\n\n    const isComponentReadyToBeDestroyed = computed(() => {\n      return (\n        (props.hideOverlay || overlayTransitionState.value === TransitionState.Leave) &&\n        modalTransitionState.value === TransitionState.Leave\n      )\n    })\n\n    const calculateZIndex = computed(() => {\n      if (props.zIndex === false) {\n        if (props.zIndexAuto) {\n          return +props.zIndexBase + 2 * (modalStackIndex.value || 0)\n        } else {\n          return false\n        }\n      } else {\n        return props.zIndex\n      }\n    })\n\n    const bindStyle = computed(() => {\n      return {\n        ...(calculateZIndex.value !== false && {\n          zIndex: calculateZIndex.value\n        })\n      }\n    })\n\n    watch(\n      () => props.modelValue,\n      value => {\n        if (_stopEvent.value) {\n          _stopEvent.value = false\n          return\n        }\n        mounted()\n        if (!value) {\n          if (emitEvent('before-close', true)) {\n            return\n          }\n          close()\n        }\n      }\n    )\n    watch(() => props.lockScroll, handleLockScroll)\n    watch(\n      () => props.hideOverlay,\n      value => {\n        if (props.modelValue && !value) {\n          visibility.overlay = true\n        }\n      }\n    )\n    watch(() => props.attach, mounted)\n    watch(\n      isComponentReadyToBeDestroyed,\n      val => {\n        if (val) {\n          visible.value = false\n        }\n      },\n      {\n        flush: 'post'\n      }\n    )\n\n    $vfm.modals.push(getModalInfo())\n\n    onMounted(() => {\n      mounted()\n    })\n    onBeforeUnmount(() => {\n      close()\n      props.lockScroll && enableBodyScroll(vfmContent)\n      root?.value?.remove()\n\n      let index = $vfm.modals.findIndex(vm => vm.uid === uid)\n      $vfm.modals.splice(index, 1)\n    })\n    function getModalInfo() {\n      return {\n        uid,\n        props,\n        emit,\n        vfmContainer,\n        vfmContent,\n        getAttachElement,\n        modalStackIndex,\n        visibility,\n        handleLockScroll,\n        $focusTrap,\n        toggle,\n        params\n      }\n    }\n    function mounted() {\n      if (props.modelValue) {\n        if (emitEvent('before-open', false)) {\n          return\n        }\n\n        let target = getAttachElement()\n        if (target || props.attach === false) {\n          props.attach !== false && target.appendChild(root.value)\n\n          let index = $vfm.openedModals.findIndex(vm => vm.uid === uid)\n\n          if (index !== -1) {\n            // if this is already exist in modalStack, delete it\n            $vfm.openedModals.splice(index, 1)\n          }\n          $vfm.openedModals.push(getModalInfo())\n\n          modalStackIndex.value = $vfm.openedModals.length - 1\n\n          handleLockScroll()\n\n          $vfm.openedModals\n            .filter(vm => vm.uid !== uid)\n            .forEach((vm, index) => {\n              if (vm.getAttachElement() === target) {\n                // if vm and this have the same attach element\n                vm.modalStackIndex.value = index\n                vm.visibility.overlay = false\n              }\n            })\n\n          visible.value = true\n          nextTick(() => {\n            startTransitionEnter()\n          })\n        } else if (target !== false) {\n          console.warn('Unable to locate target '.concat(props.attach))\n        }\n      }\n    }\n    function close() {\n      let index = $vfm.openedModals.findIndex(vm => vm.uid === uid)\n      if (index !== -1) {\n        // remove this in modalStack\n        $vfm.openedModals.splice(index, 1)\n      }\n      if ($vfm.openedModals.length > 0) {\n        // If there are still nested modals opened\n        const $_vm = $vfm.openedModals[$vfm.openedModals.length - 1]\n        $_vm.props.focusTrap && $_vm.$focusTrap.firstElement().focus()\n        if ($_vm.props.focusRetain || $_vm.props.focusTrap) {\n          $_vm.vfmContainer.value.focus()\n        }\n        !$_vm.props.hideOverlay && ($_vm.visibility.overlay = true)\n      }\n      startTransitionLeave()\n    }\n    function handleLockScroll() {\n      if (props.modelValue) {\n        if (props.lockScroll) {\n          disableBodyScroll(vfmContent, {\n            reserveScrollBarGap: true\n          })\n        } else {\n          enableBodyScroll(vfmContent)\n        }\n      }\n    }\n    function getAttachElement() {\n      let target\n      if (props.attach === false) {\n        target = false\n      } else if (typeof props.attach === 'string') {\n        // CSS selector\n        if (window) {\n          target = window.document.querySelector(props.attach)\n        } else {\n          target = false\n        }\n      } else {\n        // DOM Element\n        target = props.attach\n      }\n      return target\n    }\n    function startTransitionEnter() {\n      visibility.overlay = true\n      visibility.modal = true\n    }\n    function startTransitionLeave() {\n      visibility.overlay = false\n      visibility.modal = false\n    }\n\n    function beforeOverlayEnter() {\n      overlayTransitionState.value = TransitionState.Entering\n    }\n    function afterOverlayEnter() {\n      overlayTransitionState.value = TransitionState.Enter\n    }\n    function beforeOverlayLeave() {\n      overlayTransitionState.value = TransitionState.Leaving\n    }\n    function afterOverlayLeave() {\n      overlayTransitionState.value = TransitionState.Leave\n    }\n    function beforeModalEnter() {\n      modalTransitionState.value = TransitionState.Entering\n    }\n    function afterModalEnter() {\n      modalTransitionState.value = TransitionState.Enter\n      if (props.focusRetain || props.focusTrap) {\n        vfmContainer.value.focus()\n      }\n      if (props.focusTrap) {\n        $focusTrap.enable(vfmContainer.value)\n      }\n      emit('opened', createModalEvent({ type: 'opened' }))\n    }\n    function beforeModalLeave() {\n      modalTransitionState.value = TransitionState.Leaving\n\n      if ($focusTrap.enabled()) {\n        $focusTrap.disable()\n      }\n    }\n    function afterModalLeave() {\n      modalTransitionState.value = TransitionState.Leave\n      modalStackIndex.value = null\n      props.lockScroll && enableBodyScroll(vfmContent)\n\n      let stopEvent = false\n      const event = createModalEvent({\n        type: 'closed',\n        stop() {\n          stopEvent = true\n        }\n      })\n      emit('closed', event)\n      if (stopEvent) return\n      params.value = {}\n    }\n    function onClickContainer() {\n      emit('click-outside', createModalEvent({ type: 'click-outside' }))\n      props.clickToClose && emit('update:modelValue', false)\n    }\n    function onEsc(evt) {\n      if (evt.keyCode === 27 && visible.value && props.escToClose) {\n        emit('update:modelValue', false)\n      }\n    }\n    function createModalEvent(eventProps = {}) {\n      return {\n        ref: getModalInfo(),\n        ...eventProps\n      }\n    }\n    function emitEvent(eventType, value) {\n      let stopEvent = false\n      const event = createModalEvent({\n        type: eventType,\n        stop() {\n          stopEvent = true\n        }\n      })\n      emit(eventType, event)\n      if (stopEvent) {\n        _stopEvent.value = true\n        nextTick(() => {\n          emit('update:modelValue', value)\n        })\n        return true\n      }\n      return false\n    }\n    function toggle(show, _params) {\n      const value = typeof show === 'boolean' ? show : !props.modelValue\n      if (value && arguments.length === 2) {\n        params.value = _params\n      }\n      emit('update:modelValue', value)\n    }\n    return {\n      root,\n      vfmContent,\n      vfmContainer,\n      visible,\n      visibility,\n      params,\n      calculateZIndex,\n      bindStyle,\n      beforeOverlayEnter,\n      afterOverlayEnter,\n      beforeOverlayLeave,\n      afterOverlayLeave,\n      beforeModalEnter,\n      afterModalEnter,\n      beforeModalLeave,\n      afterModalLeave,\n      onClickContainer,\n      onEsc\n    }\n  }\n}\n</script>\n\n<style lang=\"css\" scoped>\n.vfm--fixed {\n  position: fixed;\n}\n.vfm--absolute {\n  position: absolute;\n}\n.vfm--inset {\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.vfm--overlay {\n  background-color: rgba(0, 0, 0, 0.5);\n}\n.vfm--prevent-none {\n  pointer-events: none;\n}\n.vfm--prevent-auto {\n  pointer-events: auto;\n}\n.vfm--outline-none:focus {\n  outline: none;\n}\n.vfm-enter-active,\n.vfm-leave-active {\n  transition: opacity 0.2s;\n}\n.vfm-enter-from,\n.vfm-leave-to {\n  opacity: 0;\n}\n</style>\n","import VueFinalModal from './VueFinalModal.vue'\n\nfunction createVfm() {\n  let vfm\n\n  return function() {\n    vfm = {\n      show(name, ...args) {\n        this.toggle(name, true, ...args)\n      },\n      hide(name) {\n        this.toggle(name, false)\n      },\n      hideAll() {\n        this.openedModals.forEach(modal => {\n          modal.emit('update:modelValue', false)\n        })\n      },\n      toggle(name, ...args) {\n        const modal = this.get(name)\n        if (modal !== undefined) {\n          modal.toggle(...args)\n        }\n      },\n      get(name) {\n        return this.modals.find(modal => modal.props.name === name)\n      },\n      openedModals: [],\n      modals: []\n    }\n    return vfm\n  }\n}\n\nexport function bindPrototype(app, options) {\n  const vfm = createVfm()()\n  Object.defineProperty(app.config.globalProperties, options.key, {\n    get() {\n      return vfm\n    }\n  })\n  app.provide(options.key, vfm)\n}\n\nexport function registComponent(app, options) {\n  app.component(options.componentName, {\n    ...VueFinalModal,\n    props: { ...VueFinalModal.props, options: { type: Object, default: () => options } }\n  })\n}\n","function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","export const DUPLICATE_PLUGIN_COMPONENT =\n  '[vue-final-modal] Duplicate registration API key and componentName of VueFinalModal.'\n\nexport const DUPLICATE_COMPONENT = '[vue-final-modal] Duplicate registration componentName of VueFinalModal.'\n","import { bindPrototype, registComponent } from './PluginCore'\nimport { DUPLICATE_PLUGIN_COMPONENT, DUPLICATE_COMPONENT } from './utils/errors'\n\nconst defaultOptions = {\n  componentName: 'VueFinalModal',\n  key: '$vfm'\n}\n\nconst Plugin = () => ({\n  install(app, options) {\n    const _options = Object.assign({}, defaultOptions, options)\n    const isDuplicateKey = app.config.globalProperties[_options.key]\n    const isDuplicateComponent = app._context.components[_options.componentName]\n\n    if (isDuplicateComponent) {\n      if (typeof window !== 'undefined') {\n        console.warn(isDuplicateKey ? DUPLICATE_PLUGIN_COMPONENT : DUPLICATE_COMPONENT)\n      }\n    } else {\n      if (!isDuplicateKey) {\n        bindPrototype(app, _options)\n      }\n      registComponent(app, _options)\n    }\n  }\n})\n\nexport default Plugin\n"],"names":["previousBodyOverflowSetting","previousBodyPaddingRight","queryFocusableElements","element","selector","querySelectorAll","isFocused","document","activeElement","FocusTrap","root","elements","onKeyDown","this","bind","enable","disable","firstElement","lastElement","length","event","key","keyCode","isTabPressed","shiftKey","focus","preventDefault","addEventListener","removeEventListener","locks","disableBodyScroll","targetElement","options","some","lock","undefined","reserveScrollBarGap","scrollBarGap","window","innerWidth","documentElement","clientWidth","computedBodyPaddingRight","parseInt","getComputedStyle","body","getPropertyValue","style","paddingRight","overflow","setOverflowHidden","console","error","enableBodyScroll","filter","TransitionState","name","props","type","String","default","modelValue","Boolean","ssr","classes","Object","Array","overlayClass","contentClass","styles","overlayStyle","contentStyle","lockScroll","hideOverlay","clickToClose","escToClose","preventClick","attach","validator","val","nodeType","Node","ELEMENT_NODE","transition","overlayTransition","zIndexAuto","zIndexBase","Number","zIndex","focusRetain","focusTrap","emits","setup","emit","uid","Symbol","ref","vfmContent","vfmContainer","$vfm","inject","modalStackIndex","$focusTrap","visible","visibility","reactive","modal","overlay","overlayTransitionState","modalTransitionState","_stopEvent","params","isComponentReadyToBeDestroyed","computed","value","calculateZIndex","bindStyle","getModalInfo","getAttachElement","handleLockScroll","toggle","mounted","emitEvent","target","appendChild","index","openedModals","findIndex","vm","splice","push","forEach","nextTick","warn","concat","close","$_vm","querySelector","createModalEvent","eventProps","eventType","stopEvent","stop","show","_params","arguments","watch","flush","modals","onMounted","onBeforeUnmount","remove","beforeOverlayEnter","afterOverlayEnter","beforeOverlayLeave","afterOverlayLeave","beforeModalEnter","afterModalEnter","beforeModalLeave","enabled","afterModalLeave","onClickContainer","onEsc","evt","$props","$setup","_createBlock","class","onKeydown","_createVNode","toString","role","tabindex","onClick","_renderSlot","bindPrototype","app","vfm","args","hide","hideAll","get","find","defineProperty","config","globalProperties","provide","css","insertAt","head","getElementsByTagName","createElement","firstChild","insertBefore","styleSheet","cssText","createTextNode","defaultOptions","componentName","install","_options","assign","isDuplicateKey","_context","components","component","VueFinalModal","registComponent"],"mappings":"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"}